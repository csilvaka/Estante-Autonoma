/* Multiplos controle de um Estoque Automatizado e Inteligente
 10º Semestre de Engenharia de Automação e Controle - Centro Universitario de Jaguariuna - Campus II - Jaguariùna - SP
 Trabalho de Conclusão de Curso - Estante Autonoma
 autor: Kaio Silva
 Versão 01 - 26/10/2018 */

 
  
  #include <Ultrasonic.h>
  //SensorX=Sensor 1
  #define pino_trigger1 8//Sensor X
  #define pino_echo1 7//Sensor X
   float cmMsecX;
   float lastcmMsecX;
   double setPointx = 30;
   double  KPx = 0, KIx = 0, KDx = 0;
   double  Px = 1, Ix = 1, Dx = 0;
   double PIDx = 0;
   double FowardPWMx = 0;
   double ReversePWMx = 0;
   double errorX = 0;
   
  //MotorX= Motor 1
  #define Rpwmx 3//Motor X Direta
  #define Lpwmx 9//Motor X Esquerda
  
  //SensorY=Sensor 2
  #define pino_trigger2 13//Sensor Y
  #define pino_echo2 12//Sensor Y
  float cmMsecY;
  float lastcmMsecY;
  double setPointy = 69;
  double  KPy = 2, KIy = 0, KDy = 0;
  double  Py = 1, Iy = 0, Dy = 0;
  double PIDy = 0;
  double FowardPWMy = 0;
   double ReversePWMy = 0;
  double errorY = 0;

  
 //MotorY= Motor 2
  #define Rpwmy 10// Motor Y Direita
  #define Lpwmy 11//Motor Y Esquerda

float Ima;
float Trava;
  #define ima 2
  #define trava 4
  
  
 
  long lastProcess;
  Ultrasonic ultrasonic1(pino_trigger1, pino_echo1);
  Ultrasonic ultrasonic2(pino_trigger2, pino_echo2);
  
void setup() {
  Serial.begin(9600);
  pinMode(Rpwmx, OUTPUT);
  pinMode(Lpwmx, OUTPUT);
  pinMode(Rpwmy, OUTPUT);
  pinMode(Lpwmy, OUTPUT);
  pinMode(ima, OUTPUT);
  pinMode(trava, OUTPUT);

  
}


void loop() {



//  Calculo e leitura das distancias X e Y dos sensores ultrassonicos

//sensor X
  long microsecX = ultrasonic1.timing();
  cmMsecX = ultrasonic1.convert(microsecX, Ultrasonic::CM);
  cmMsecX=map(cmMsecX,  4,  38, 0, 100);
 
//Sensor Y
 long microsecY = ultrasonic2.timing();
 cmMsecY = ultrasonic2.convert(microsecY, Ultrasonic::CM);
 cmMsecY=map(cmMsecY,  5.65,  42.66, 0, 100);

 
  //implementação PID
  errorX = setPointx - cmMsecX;
  errorY = setPointy - cmMsecY;
  
  float deltatime = (millis() - lastProcess) / 1000.0; 
  lastProcess = millis();
  
  Px= errorX * KPx;
  Py= errorY * KPy;
  
 // Ix += (errorX * KIx) * deltatime;
 //Iy += (errorY * KIy) * deltatime;
  
 // Dx = (lastcmMsecX - cmMsecX) *KDx / deltatime;
 //Dy = (lastcmMsecY - cmMsecY) *KDy / deltatime;
 // lastcmMsecX = cmMsecX;
 lastcmMsecY = cmMsecY;
  
  PIDx =  Px + Ix + Dx;
  PIDy = Py + Iy + Dy;
    
//Limitação em X
if(PIDx>255)
{
PIDx=255;
}
if (PIDx<=0)
{
  PIDx=0;
}

//Limitação em Y
if(PIDy>255)
{
PIDy=255;
}
if (PIDy<=0)
{
  PIDy=0;
}

PIDy=abs(PIDy);

PIDx= map(PIDx,  30,  255, 0, 255);
PIDy= map(PIDy,  0,  255, 30, 255);

//Saída em X
 if (errorX <0)
  {
    // reverse rotation
    ReversePWMx=PIDx;
    FowardPWMx=0;
    analogWrite(Lpwmx, FowardPWMx);
    analogWrite(Rpwmx, ReversePWMx);
  } else {
    // forward rotation
    FowardPWMx=PIDx;
    ReversePWMx=0;
    analogWrite(Lpwmx, FowardPWMx);
    analogWrite(Rpwmx, ReversePWMx);
  }
  
//Saída em Y
 if (errorY <0)
  {
    // reverse rotation
    ReversePWMy=(PIDx);
    FowardPWMy=0;
    analogWrite(Lpwmy, FowardPWMy);
    analogWrite(Rpwmy, ReversePWMy);
  } else {
    // forward rotation
    FowardPWMy=(PIDy);
    ReversePWMy=0;
    analogWrite(Lpwmy, FowardPWMy);
    analogWrite(Rpwmy, ReversePWMy);
  }

    Ima= LOW;
  Trava= LOW;
  digitalWrite(ima,Ima);
  digitalWrite(trava,Trava);
delay(5000);
      Ima= HIGH;
  Trava= HIGH;
  digitalWrite(ima,Ima);
  digitalWrite(trava,Trava);}
/*controlePWMx = PIDx;
analogWrite(pCONTROLE1xR, controlePWMx);
digitalWrite(5, HIGH);                      
  digitalWrite(6, LOW);  
}
    else
    controlePWMx = (PIDx*(-1));
    analogWrite(pCONTROLE1xL, controlePWMx);
 digitalWrite(5,LOW );                      
  digitalWrite(6,HIGH);   
if(PIDy>=0){
controlePWMy =PIDy;
analogWrite(pCONTROLE2yR, controlePWMy);}
    else
    controlePWMy = (PIDy*(-1));
    analogWrite(pCONTROLE2yL, controlePWMy);
*/
  //Exibe informacoes no serial monitor
  Serial.print(" DistanciaX em cm: ");
  Serial.print(cmMsecX); 
  Serial.print(" Erro em X  ");
  Serial.print(errorX);

  Serial.print(" ReverseX: ");
  Serial.print(ReversePWMx);
   Serial.print(" FowardX: ");
  Serial.print(FowardPWMx);



  Serial.print(" DistanciaY em cm: ");
  Serial.print(cmMsecY);
 Serial.print(" Erro em Y  ");
 Serial.print(errorY);
  
  Serial.print(" ReverseY: ");
  Serial.print(ReversePWMy);
   Serial.print(" FowardY: ");
  Serial.print(FowardPWMy);
     Serial.print(" ima: ");
  Serial.print(ima);
     Serial.print(" Trava: ");
Serial.print(trava);

  /*Serial.print(" yL: ");
  Serial.print(controlePWMy);
   Serial.print(" yR: ");
  Serial.println(controlePWMy);
  delay(1000);
*/

}
